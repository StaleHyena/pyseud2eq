use crate::ast::{Target, ExprSet, Expr, ExprKind, Value, Opcode, Scope};
use std::str::FromStr;
use lalrpop_util::ParseError;

grammar(scope: &mut Scope);

pub Target: Target = {
	<e:FinalExpr> => Target::Expr(e),
	<set:ExprSet> => Target::ExprSet(set),
};

pub ExprSet: ExprSet = {
	<FinalExpr> ";" <FinalExpr> => ExprSet(vec![<>]),
	<mut set:ExprSet> ";" <e:FinalExpr> => {
		set.push(e);
		set
	},
};

pub FinalExpr: Box<Expr> = {
	Expr,
	Equation,
}

pub Equation: Box<Expr> = {
	Expr EquationOp Expr => Box::new(Expr::new(ExprKind::BinaryOp(<>), 1)),
	<mut l:Equation> <o:EquationOp> <r:Expr> => {
		l.prio = 0;
		Box::new(Expr::new(ExprKind::BinaryOp(<>), 1))
	},
};

pub EquationOp: Opcode = {
	"=" => Opcode::Equals,
	"~=" => Opcode::ApproxEquals,
	"!=" => Opcode::NotEquals,
	">" => Opcode::GreaterThan,
	"<" => Opcode::LesserThan,
	">=" => Opcode::GtEquals,
	"<=" => Opcode::LtEquals,
};

pub Expr: Box<Expr> = {
	Expr ExprOp Factor => Box::new(Expr::new(ExprKind::BinaryOp(<>), 0)),
	ExprOp Factor => Box::new(Expr::new(ExprKind::UnaryOp(<>), 0)),
	Factor,
};

ExprOp: Opcode = {
	"+" => Opcode::Add,
	"-" => Opcode::Sub,
};

Factor: Box<Expr> = {
	Factor FactorOp Term => Box::new(Expr::new(ExprKind::BinaryOp(<>), 0)),
	Term,
};

FactorOp: Opcode = {
	"**" => Opcode::Superscript,
	"__" => Opcode::Superscript,
	"_"  => Opcode::Subscript,
	"*"  => Opcode::Mul,
	"/"  => Opcode::Div,
};

Term: Box<Expr> = {
	Value => Box::new(Expr::new(ExprKind::Value(<>), 0)),
	"(" <e:Expr> ")" => Box::new(Expr::new(e.v, e.prio + 1)),
	<fname:Name> "(" <mut fargs:Expr> ")" => {
		let s = fname.to_owned();
		fargs.prio += 1;
		Box::new(Expr::new(ExprKind::Function(s,fargs), 0))
	}
};

Value: Box<Value> = {
	<Name> => Box::new(Value::new(<>.to_owned(), None, None)),
	<FloatU> => Box::new(Value::new((<>.0).to_string(), Some(<>.0), <>.1)),
};

FloatU: (f64, Option<String>) = {
  <n:Float> ":" "(" <u:Expr> ")" => (n, Some(u.to_string().to_owned())),
  <Float> => (<>, None),
};
//Name: &'input str = r#"[[:alpha:]]([[:alpha:]]|['"\^\~%@`\&\?!\[\]`°µ])*"#;
Name: &'input str = r#"[\S--[[0-9]._\+\-\*/=!\~():]][\S--[_\+\-\*/=!\~():]]*"#;
Float: f64 = r#"[+-]?([0-9]*[.])?[0-9]+([eE][+-]?[0-9]+)?"# =>? f64::from_str(<>)
  .map_err(|_| ParseError::User { error: "Couldn't parse float value!" });

