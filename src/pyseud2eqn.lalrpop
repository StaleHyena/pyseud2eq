use crate::ast::{Target, ExprSet, Expr, ExprKind, Opcode, Scope};
use std::str::FromStr;
use lalrpop_util::ParseError;

grammar(scope: &mut Scope);

pub Target: Target = {
	<e:FinalExpr> => Target::Expr(e),
	<set:ExprSet> => Target::ExprSet(set),
};

pub ExprSet: ExprSet = {
	<FinalExpr> ";" <FinalExpr> => ExprSet(vec![<>]),
	<mut set:ExprSet> ";" <e:FinalExpr> => {
		set.push(e);
		set
	},
};

pub FinalExpr: Box<Expr> = {
	Expr,
	Equation,
}

//FIXME dry this code
pub Equation: Box<Expr> = {
	Expr EquationOp Expr => Box::new(Expr::new(ExprKind::BinaryOp(<>), None).process(scope)),
	Equation EquationOp Expr => Box::new(Expr::new(ExprKind::BinaryOp(<>), None).process(scope)),
};

pub EquationOp: Opcode = {
	"=" => Opcode::Equals,
	"~=" => Opcode::ApproxEquals,
	"!=" => Opcode::NotEquals,
	">" => Opcode::GreaterThan,
	"<" => Opcode::LesserThan,
	">=" => Opcode::GtEquals,
	"<=" => Opcode::LtEquals,
};

pub Expr: Box<Expr> = {
	Expr ExprOp Factor => Box::new(Expr::new(ExprKind::BinaryOp(<>), None)),
	ExprOp Factor => Box::new(Expr::new(ExprKind::UnaryOp(<>), None)),
	Factor,
};

ExprOp: Opcode = {
	"+" => Opcode::Add,
	"-" => Opcode::Sub,
  "@" => Opcode::At,
};

Factor: Box<Expr> = {
	Factor FactorOp UTerm => Box::new(Expr::new(ExprKind::BinaryOp(<>), None)),
	UTerm,
};

// TODO/FIXME: sup/subscript should have greater precedence
FactorOp: Opcode = {
	"*"  => Opcode::Mul,
	"/"  => Opcode::Div,
	"**" => Opcode::Superscript,
	"__" => Opcode::Superscript,
	"_"  => Opcode::Subscript,
};

pub UTerm: Box<Expr> = {
  <mut v:Term> ":" "(" <u:Expr> ")" => {
    v.unit = Some(u.to_string().to_owned());
    v
  },
  Term,
};

Term: Box<Expr> = {
	<Ident> => Box::new(Expr::new(ExprKind::Ident(<>), None)),
	<Float> => Box::new(Expr::from(<>)),

	"(" <e:Expr> ")" => e,
};

Ident: String = {
  Name => <>.to_owned(),
	<fname:Ident> "(" <fargs:Expr> ")" => format!("{}({})", fname, fargs),
  // Botch for indexing
  <mut id:Ident> <idx:r"\[[0-9]+\]"> => { id.push_str(idx); id },
};

Name: &'input str = r#"[\S--[[0-9]._\+\-\*/=!\~():\[\]]][\S--[_\+\-\*/=!\~():\[\]]]*"#;
Float: f64 = r#"[+-]?([0-9]*[.])?[0-9]+([eE][+-]?[0-9]+)?"# =>? f64::from_str(<>)
  .map_err(|_| ParseError::User { error: "Couldn't parse float value!" });

