use crate::ast::{Target, ExprSet, Expr, ExprKind, Opcode, Scope};
use std::str::FromStr;
use lalrpop_util::ParseError;

grammar(scope: &mut Scope);

pub Target: Target = {
	<e:FinalExpr> => Target::Expr(e),
	<set:ExprSet> => Target::ExprSet(set),
};

pub ExprSet: ExprSet = {
	<FinalExpr> ";" <FinalExpr> => ExprSet(vec![<>]),
	<mut set:ExprSet> ";" <e:FinalExpr> => {
		set.push(e);
		set
	},
};

pub FinalExpr: Box<Expr> = {
	Expr,
	Equation,
}

//FIXME dry this code
pub Equation: Box<Expr> = {
	<l:Expr> <o:EquationOp> <mut r:Expr> => {
    use ExprKind::*;
    if let Ident(rname) = r.v.clone() {
      if rname == scope.autocalc_ident {
        if let Some(val) = l.eval(scope) {
          r.v = Constant(val);
        } else {
          r.v = Ident("unknown".to_string());
        }
      }
    }
    let e = Expr::new(BinaryOp(l.clone(), o, r.clone()), None);
    if let Some(val) = e.eval(scope) {
      if let Ident(id) = l.v {
        scope.known.insert(format!("{}", id), val);
      }
      if let Ident(id) = r.v {
        scope.known.insert(format!("{}", id), val);
      }
    }
    Box::new(e)
  },
	<eqn:Equation> <o:EquationOp> <mut exp:Expr> => {
    use ExprKind::*;
    if let Ident(expname) = exp.v.clone() {
      if expname == scope.autocalc_ident {
        if let Some(val) = eqn.eval(scope) {
          exp.v = Constant(val);
        } else {
          exp.v = Ident("unknown".to_string());
        }
      }
    }
    let e = Expr::new(BinaryOp(eqn.clone(), o, exp.clone()), None);
    if let BinaryOp(lhs, _, rhs) = eqn.v {
      if let Some(val) = e.eval(scope) {
        if let Ident(id) = lhs.v {
          scope.known.insert(format!("{}", id), val);
        }
        if let Ident(id) = rhs.v {
          scope.known.insert(format!("{}", id), val);
        }
        if let Ident(id) = exp.v {
          scope.known.insert(format!("{}", id), val);
        }
      }
    }
    Box::new(e)
  }
};

pub EquationOp: Opcode = {
	"=" => Opcode::Equals,
	"~=" => Opcode::ApproxEquals,
	"!=" => Opcode::NotEquals,
	">" => Opcode::GreaterThan,
	"<" => Opcode::LesserThan,
	">=" => Opcode::GtEquals,
	"<=" => Opcode::LtEquals,
};

pub Expr: Box<Expr> = {
	Expr ExprOp Factor => Box::new(Expr::new(ExprKind::BinaryOp(<>), None)),
	ExprOp Factor => Box::new(Expr::new(ExprKind::UnaryOp(<>), None)),
	Factor,
};

ExprOp: Opcode = {
	"+" => Opcode::Add,
	"-" => Opcode::Sub,
  "@" => Opcode::At,
};

Factor: Box<Expr> = {
	Factor FactorOp UTerm => Box::new(Expr::new(ExprKind::BinaryOp(<>), None)),
	UTerm,
};

// TODO/FIXME: sup/subscript should have greater precedence
FactorOp: Opcode = {
	"*"  => Opcode::Mul,
	"/"  => Opcode::Div,
};

pub UTerm: Box<Expr> = {
  <mut v:Term> ":" "(" <u:Expr> ")" => {
    v.unit = Some(u.to_string().to_owned());
    v
  },
  Term,
};

Term: Box<Expr> = {
	<Ident> => Box::new(Expr::new(ExprKind::Ident(<>), None)),
	<Float> => Box::new(Expr::from(<>)),

	"(" <e:Expr> ")" => Box::new(Expr::new(e.v, e.unit)),
	<fname:Name> "(" <fargs:Expr> ")" => {
		let s = fname.to_owned();
		Box::new(Expr::new(ExprKind::Function(s,fargs), None))
	},
  // Botch for indexing
  <mut t:Term> <idx:r"\[[0-9]+\]"> => {
    let mut s: String = t.v.to_string().to_owned();
    s.push_str(idx);
    t.v = ExprKind::Ident(s);
    t
  },
};

Ident: String = {
  Name IdentOp Name => format!("{} {} {{ {} }}", <>),
  Name IdentOp Float => format!("{} {} {{ {} }}", <>),
  Float IdentOp Name => format!("{} {} {{ {} }}", <>),
  Float IdentOp Float => format!("{} {} {{ {} }}", <>),
  Name => <>.to_owned(),
};

IdentOp: Opcode = {
	"**" => Opcode::Superscript,
	"__" => Opcode::Superscript,
	"_"  => Opcode::Subscript,
};


Name: &'input str = r#"[\S--[[0-9]._\+\-\*/=!\~():\[\]]][\S--[_\+\-\*/=!\~():\[\]]]*"#;
Float: f64 = r#"[+-]?([0-9]*[.])?[0-9]+([eE][+-]?[0-9]+)?"# =>? f64::from_str(<>)
  .map_err(|_| ParseError::User { error: "Couldn't parse float value!" });

