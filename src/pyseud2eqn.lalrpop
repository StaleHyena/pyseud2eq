use crate::ast::{Expr, ExprKind, Opcode};

grammar;

pub Equation: Box<Expr> = {
	Equation EquationOp Expr => Box::new(Expr { v: ExprKind::BinaryOp(<>), l: 0 }),
	Expr,
};

pub EquationOp: Opcode = {
	"=" => Opcode::Equals,
	"!=" => Opcode::NotEquals,
	">" => Opcode::GreaterThan,
	"<" => Opcode::LesserThan,
	">=" => Opcode::GtEquals,
	"<=" => Opcode::LtEquals,
};

pub Expr: Box<Expr> = {
	Expr ExprOp Factor => Box::new(Expr { v: ExprKind::BinaryOp(<>), l: 0 }),
	ExprOp Factor => Box::new(Expr { v: ExprKind::UnaryOp(<>), l: 0 }),
	Factor,
};

Marker = r"[\.\s](?i)EQPY";
pub Target: String = {
	Marker <Equation> Marker => (<>).to_string(),
};

ExprOp: Opcode = {
	"+" => Opcode::Add,
	"-" => Opcode::Sub,
};

Factor: Box<Expr> = {
	Factor FactorOp Term => Box::new(Expr { v: ExprKind::BinaryOp(<>), l: 0, }),
	Term,
};

FactorOp: Opcode = {
	"**" => Opcode::Superscript,
	"__" => Opcode::Superscript,
	"_"  => Opcode::Subscript,
	"*"  => Opcode::Mul,
	"/"  => Opcode::Div,
};

Term: Box<Expr> = {
	Ident => Box::new(Expr {
		v: ExprKind::Ident(<>),
		l: 0,
	}),
	"(" <Expr> ")" => {
		Box::new(Expr {
			v: (<>).v,
			l: (<>).l + 1,
		})
	},
};

Ident: String = {
	Name => (<>).to_owned(),
	// Slight bug with the signs
	Name "." Name => format!("{}{}{}", <>),
	Name Name => format!("{} {}", <>),
};

Name: &'input str = r#"[[[:alnum:]]|['"\^\~%@`\&\?!\[\]`\&]]+"#;

