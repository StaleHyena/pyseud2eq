use crate::ast::{Target, ExprSet, Expr, ExprKind, Value, Opcode, Scope};
use std::str::FromStr;
use lalrpop_util::ParseError;

grammar(scope: &mut Scope);

pub Target: Target = {
	<e:FinalExpr> => Target::Expr(e),
	<set:ExprSet> => Target::ExprSet(set),
};

pub ExprSet: ExprSet = {
	<FinalExpr> ";" <FinalExpr> => ExprSet(vec![<>]),
	<mut set:ExprSet> ";" <e:FinalExpr> => {
		set.push(e);
		set
	},
};

pub FinalExpr: Box<Expr> = {
	Expr,
	Equation,
}

pub Equation: Box<Expr> = {
	Expr EquationOp Expr => Box::new(Expr::new(ExprKind::BinaryOp(<>), None)),
	<l:Equation> <o:EquationOp> <r:Expr> => {
		Box::new(Expr::new(ExprKind::BinaryOp(<>), None))
	},
};

pub EquationOp: Opcode = {
	"=" => Opcode::Equals,
	"~=" => Opcode::ApproxEquals,
	"!=" => Opcode::NotEquals,
	">" => Opcode::GreaterThan,
	"<" => Opcode::LesserThan,
	">=" => Opcode::GtEquals,
	"<=" => Opcode::LtEquals,
};

pub Expr: Box<Expr> = {
	Expr ExprOp Factor => Box::new(Expr::new(ExprKind::BinaryOp(<>), None)),
	ExprOp Factor => Box::new(Expr::new(ExprKind::UnaryOp(<>), None)),
	Factor,
};

ExprOp: Opcode = {
	"+" => Opcode::Add,
	"-" => Opcode::Sub,
  "@" => Opcode::At,
};

Factor: Box<Expr> = {
	Factor FactorOp UTerm => Box::new(Expr::new(ExprKind::BinaryOp(<>), None)),
	UTerm,
};

// TODO/FIXME: sup/subscript should have greater precedence
FactorOp: Opcode = {
	"**" => Opcode::Superscript,
	"__" => Opcode::Superscript,
	"_"  => Opcode::Subscript,
	"*"  => Opcode::Mul,
	"/"  => Opcode::Div,
};

UTerm: Box<Expr> = {
  <mut v:Term> ":" "(" <u:Expr> ")" => {
    v.unit = Some(u.to_string().to_owned());
    v
  },
  Term,
};

Term: Box<Expr> = {
	Value => Box::new(Expr::new(ExprKind::Value(<>), None)),
	"(" <e:Expr> ")" => Box::new(Expr::new(e.v, e.unit)),
	<fname:Name> "(" <fargs:Expr> ")" => {
		let s = fname.to_owned();
		Box::new(Expr::new(ExprKind::Function(s,fargs), None))
	},
  // Botch for indexing
  <mut t:Term> <idx:r"\[[0-9]+\]"> => {
    let mut s: String = t.v.to_string().to_owned();
    s.push_str(idx);
    t.v = ExprKind::Value(Box::new(Value::new(s, None)));
    t
  },
};

Value: Box<Value> = {
	<Name> => Box::new(Value::new(<>.to_owned(), None)),
	<Float> => Box::new(Value::new(<>.to_string(), None)),
};

Name: &'input str = r#"[\S--[[0-9]._\+\-\*/=!\~():\[\]]][\S--[_\+\-\*/=!\~():\[\]]]*"#;
Float: f64 = r#"[+-]?([0-9]*[.])?[0-9]+([eE][+-]?[0-9]+)?"# =>? f64::from_str(<>)
  .map_err(|_| ParseError::User { error: "Couldn't parse float value!" });

