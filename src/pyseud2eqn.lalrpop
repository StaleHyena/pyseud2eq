use crate::ast::{Target, Expr, ExprKind, Equation, Opcode};

#[LALR]
grammar;

pub Target: Target = {
	Equation => Target::Equation(<>),
	LoneExpr => Target::Expr(<>),
};

pub Equation: Equation = {
	Expr EquationOp Expr => (<>).into(),
};

pub EquationOp: Opcode = {
	"=" => Opcode::Equals,
	"!=" => Opcode::NotEquals,
	">" => Opcode::GreaterThan,
	"<" => Opcode::LesserThan,
	">=" => Opcode::GtEquals,
	"<=" => Opcode::LtEquals,
};

pub Expr: Box<Expr> = {
	Expr ExprOp Factor => Box::new(Expr { v: ExprKind::BinaryOp(<>), l: 0 }),
	ExprOp Factor => Box::new(Expr { v: ExprKind::UnaryOp(<>), l: 0 }),
	Factor,
};

Marker = r"\.|\s(?i)EQPY";
LoneExpr: Box<Expr> = Marker <Expr> Marker;

ExprOp: Opcode = {
	"+" => Opcode::Add,
	"-" => Opcode::Sub,
};

Factor: Box<Expr> = {
	Factor FactorOp Term => Box::new(Expr { v: ExprKind::BinaryOp(<>), l: 0, }),
	Term,
};

FactorOp: Opcode = {
	"**" => Opcode::Superscript,
	"__" => Opcode::Superscript,
	"_"  => Opcode::Subscript,
	"*"  => Opcode::Mul,
	"/"  => Opcode::Div,
};

Term: Box<Expr> = {
	Ident => Box::new(Expr {
		v: ExprKind::Ident(<>),
		l: 0,
	}),
	"(" <Expr> ")" => {
		Box::new(Expr {
			v: (<>).v,
			l: (<>).l + 1,
		})
	},
};

Ident: String = {
	Name => (<>).to_owned(),
	// Slight bug with the signs
	Name "." Name => {
		format!("{}{}{}", <>)
	},
};

Name: &'input str = r#"[[[:alnum:]]|['"\^%@`\&\?!\[\]`\&]]+"#;

