use crate::ast::{Target, ExprSet, Expr, ExprKind, Opcode};

grammar;

Marker = r"[\.\s](?i)EQPY";
pub Target: Target = {
	Marker <e:FinalExpr> Marker => Target::Expr(e),
	Marker <set:ExprSet> Marker => Target::ExprSet(set),
};

pub ExprSet: ExprSet = {
	<FinalExpr> ";" <FinalExpr> => ExprSet(vec![<>]),
	<mut set:ExprSet> ";" <e:FinalExpr> => {
		set.push(e);
		set
	},
};

pub FinalExpr: Box<Expr> = {
	Expr,
	Equation,
}

pub Equation: Box<Expr> = {
	Expr EquationOp Expr => Box::new(Expr::new(ExprKind::BinaryOp(<>), 0)),
};

pub EquationOp: Opcode = {
	"=" => Opcode::Equals,
	"~=" => Opcode::AboutEquals,
	"!=" => Opcode::NotEquals,
	">" => Opcode::GreaterThan,
	"<" => Opcode::LesserThan,
	">=" => Opcode::GtEquals,
	"<=" => Opcode::LtEquals,
};

pub Expr: Box<Expr> = {
	Expr ExprOp Factor => Box::new(Expr::new(ExprKind::BinaryOp(<>), 0)),
	ExprOp Factor => Box::new(Expr::new(ExprKind::UnaryOp(<>), 0)),
	Factor,
};

ExprOp: Opcode = {
	"+" => Opcode::Add,
	"-" => Opcode::Sub,
};

Factor: Box<Expr> = {
	Factor FactorOp Term => Box::new(Expr::new(ExprKind::BinaryOp(<>), 0)),
	Term,
};

FactorOp: Opcode = {
	"**" => Opcode::Superscript,
	"__" => Opcode::Superscript,
	"_"  => Opcode::Subscript,
	"*"  => Opcode::Mul,
	"/"  => Opcode::Div,
};

Term: Box<Expr> = {
	Ident => Box::new(Expr::new(ExprKind::Ident(<>), 0)),
	"(" <e:Expr> ")" => Box::new(Expr::new(e.v, e.prio + 1)),
	<l:Term> <r:Ident> => {
		let mut s = l.v.to_string();
		s.push_str(r.to_string().as_str());
		Box::new(Expr::new(ExprKind::Ident(s), l.prio))
	},
};

Ident: String = {
	<n:Name> => n.to_owned(),
	Name "." Name => [<>].concat(),
};

Name: &'input str = r#"[[[:alnum:]]|['"\^\~%@`\&\?!\[\]`\&]]+"#;

