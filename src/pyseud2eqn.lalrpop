use crate::ast::{Target, ExprSet, Expr, ExprKind, Opcode, Opcode::*, Scope};
use std::str::FromStr;
use lalrpop_util::ParseError;

grammar(scope: &mut Scope);

pub Target: Target = {
	<e:FinalExpr> => Target::Expr(e),
	<set:ExprSet> => Target::ExprSet(set),
};

pub ExprSet: ExprSet = {
	<FinalExpr> ";" <FinalExpr> => ExprSet(vec![<>]),
	<mut set:ExprSet> ";" <e:FinalExpr> => {
		set.push(e);
		set
	},
};

pub FinalExpr: Box<Expr> = {
	Expr,
	Equation,
}

//FIXME dry this code
pub Equation: Box<Expr> = {
	Expr EquationOp Expr => Box::new(Expr::new(ExprKind::BinaryOp(<>)).process(scope)),
	Equation EquationOp Expr => Box::new(Expr::new(ExprKind::BinaryOp(<>)).process(scope)),
};

pub EquationOp: Opcode = {
	"=" => Equals,
	"~=" => ApproxEquals,
	"!=" => NotEquals,
	">" => GreaterThan,
	"<" => LesserThan,
	">=" => GtEquals,
	"<=" => LtEquals,
};

pub Expr: Box<Expr> = {
	Expr ExprOp FactorLate => Box::new(Expr::new(ExprKind::BinaryOp(<>))),
	ExprOp FactorLate => Box::new(Expr::new(ExprKind::UnaryOp(<>))),
	FactorLate,
};

ExprOp: Opcode = {
	"+" => Add,
	"-" => Sub,
  "@" => At,
};

FactorLate: Box<Expr> = {
	FactorLate FactorOpLate FactorEarly => Box::new(Expr::new(ExprKind::BinaryOp(<>))),
	FactorEarly,
};

FactorOpLate: Opcode = {
	"*"  => Mul,
	"/"  => Div,
};

FactorEarly: Box<Expr> = {
  FactorEarly FactorOpEarly UTerm => Box::new(Expr::new(ExprKind::BinaryOp(<>))),
  UTerm,
};

FactorOpEarly: Opcode = {
	"**" => Pow,
};

// Term with an unit
pub UTerm: Box<Expr> = {
  <mut v:Term> ":" "(" <u:Expr> ")" => {
    v.unit = Some(u.to_string().to_owned());
    v
  },
  Term,
};

Term: Box<Expr> = {
	FQIdent,
	<Float> => Box::new(Expr::from(<>)),
	"(" <Expr> ")"
};

// "Fully Qualified", has indexing info too
FQIdent: Box<Expr> =
  <mut id:Ident> <idx:r"\[[0-9]+\]"?> => {
  if let Some(j) = idx {
    if let ExprKind::Ident(idstr) = &mut id.v {
      idstr.push_str(j);
    }
  }
  id
};

// sub/superscript nesting is now left associative, but it should be right associative
// need to find a good way to fix this within the constraints of LR(1)
Ident: Box<Expr> = {
  // FIXME: function calls should be separate from the argument(s)
	<fname:Ident> "(" <fargs:Expr> ")" => Box::new(Expr::new(ExprKind::Ident(format!("{}({})", fname, fargs)))),

  <a:Ident> <op:IdentOp> <b:Name> => {
    let temp = ExprKind::BinaryOp(a, op, b);
    Box::new(Expr::new(ExprKind::Ident(temp.to_string())))
  },
  <a:Ident> <op:IdentOp> <b:Float> => {
    let temp = ExprKind::BinaryOp(a, op, Box::new(Expr::from(b)));
    Box::new(Expr::new(ExprKind::Ident(temp.to_string())))
  },

  Name
};

IdentOp: Opcode = {
	"__" => Superscript,
	"_"  => Subscript,
};

Name: Box<Expr> = {
  NameChars => Box::new(Expr::new(ExprKind::Ident(<>.to_owned()))),
}

NameChars: &'input str = r#"[\S--[[0-9]._\+\-\*/=!\~():\[\];]][\S--[_\+\-\*/=!\~():\[\];]]*"#;
Float: f64 = r#"([0-9]*[.])?[0-9]+([eE][+-]?[0-9]+)?"# =>? f64::from_str(<>)
  .map_err(|_| ParseError::User { error: "Couldn't parse float value!" });

